<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Go by Example - IT: Gestione dello Stato con Goroutine</title>
    <link rel=stylesheet href="site.css">
  </head>
  <body>
    <div class="example" id="gestione-dello-stato-con-goroutine">
      <h2><a href="./">Go by Example - IT</a>: Gestione dello Stato con Goroutine</h2>
      
      <table>
        
        <tr>
          <td class="docs">
            <p>Nell&rsquo;esempio precedente abbiamo usato il lock esplicito
insieme alle mutex per sincronizzare l&rsquo;accesso allo
stato condiviso da più goroutine. Un&rsquo;altra opzione è
quella di utilizzare le funzionalità di sincronizzazione
native di Go, sfruttando goroutine e channel per ottenere
lo stesso risultato. Questo approcchio channel-based
risulta più in linea con il principio di Go di avere la
memoria condivisa tramite la comunicazione, ed ogni
goroutine con la propria memoria privata.</p>

          </td>
          <td class="code empty leading">
	        
            
          </td>
        </tr>
        
        <tr>
          <td class="docs">
            
          </td>
          <td class="code leading">
	        <a href="http://play.golang.org/p/Forbidden"><img title="Run code" src="play.png" class="run" /></a>
            <div class="highlight"><pre><span class="kn">package</span> <span class="nx">main</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            
          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math/rand&quot;</span>
    <span class="s">&quot;sync/atomic&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            <p>In questo esempio lo stato verrà gestito da una singola
goroutine. Questo ci garantirà che i dati non verranno
mai corrotti da accessi concorrenti. Per poter leggere
ed aggiornare lo stato le altre goroutine dovranno inviare
dei messaggi alla goroutine proprietaria che risponderà
con un messaggio contenente il dato richiesto.
Le <code>struct</code> <code>readOp</code> e <code>writeOp</code> incapsulano queste
richieste e contengono il field <code>resp</code> per indicare
la risposta della goroutine proprietaria.</p>

          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre><span class="kd">type</span> <span class="nx">readOp</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">key</span>  <span class="kt">int</span>
    <span class="nx">resp</span> <span class="kd">chan</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">writeOp</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">key</span>  <span class="kt">int</span>
    <span class="nx">val</span>  <span class="kt">int</span>
    <span class="nx">resp</span> <span class="kd">chan</span> <span class="kt">bool</span>
<span class="p">}</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            
          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            <p>Come prima terremo conto del numero di operazioni
che andremo ad eseguire</p>

          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre>    <span class="kd">var</span> <span class="nx">ops</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">0</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            <p>I channel <code>reads</code> e <code>writes</code> saranno utilizzati
dalle altre goroutine per effettuare richieste
di lettura e di scrittura dello stato.</p>

          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre>    <span class="nx">reads</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">readOp</span><span class="p">)</span>
    <span class="nx">writes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">writeOp</span><span class="p">)</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            <p>Questa sarà la goroutine che gestirà lo stato,
rappresentato da una map come nell&rsquo;esempio precedente,
ma in questo caso visibile solo alla goroutine.
Questa goroutine effettuerà delle <code>select</code> sui due
channel e risponderà alle richieste che arrivano.
La goroutine si occuperà di gestire la richiesta e
restituirà un valore sul channel <code>resp</code> per indicare
un successo (nel caso di una richiesta <code>reads</code> verrà
restituito il valore richiesto).</p>

          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre>    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">state</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">read</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">reads</span><span class="p">:</span>
                <span class="nx">read</span><span class="p">.</span><span class="nx">resp</span> <span class="o">&lt;-</span> <span class="nx">state</span><span class="p">[</span><span class="nx">read</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span>
            <span class="k">case</span> <span class="nx">write</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">writes</span><span class="p">:</span>
                <span class="nx">state</span><span class="p">[</span><span class="nx">write</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">write</span><span class="p">.</span><span class="nx">val</span>
                <span class="nx">write</span><span class="p">.</span><span class="nx">resp</span> <span class="o">&lt;-</span> <span class="kc">true</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            <p>Quì facciamo partire 100 goroutine che eseguiranno
delle richieste di lettura dello stato verso la
goroutine proprietaria tramite il channel <code>reads</code>.
Ogni richiesta deve essere eseguita tramite la struct
<code>readOp</code>, inviata sul channel <code>reads</code> e si attende
il suo risultato sul channel <code>resp</code>.</p>

          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre>    <span class="k">for</span> <span class="nx">r</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">r</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">{</span>
                <span class="nx">read</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">readOp</span><span class="p">{</span>
                    <span class="nx">key</span><span class="p">:</span>  <span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
                    <span class="nx">resp</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)}</span>
                <span class="nx">reads</span> <span class="o">&lt;-</span> <span class="nx">read</span>
                <span class="o">&lt;-</span><span class="nx">read</span><span class="p">.</span><span class="nx">resp</span>
                <span class="nx">atomic</span><span class="p">.</span><span class="nx">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ops</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            <p>Avviamo anche altre 10 goroutine che effettueranno
delle scritture utilizzando un approccio simile.</p>

          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre>    <span class="k">for</span> <span class="nx">w</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">w</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">{</span>
                <span class="nx">write</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">writeOp</span><span class="p">{</span>
                    <span class="nx">key</span><span class="p">:</span>  <span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
                    <span class="nx">val</span><span class="p">:</span>  <span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
                    <span class="nx">resp</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)}</span>
                <span class="nx">writes</span> <span class="o">&lt;-</span> <span class="nx">write</span>
                <span class="o">&lt;-</span><span class="nx">write</span><span class="p">.</span><span class="nx">resp</span>
                <span class="nx">atomic</span><span class="p">.</span><span class="nx">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ops</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            <p>Facciamo eseguire le goroutine per un secondo.</p>

          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre>    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            <p>Infine leggiamo il valore della variabile <code>ops</code>.</p>

          </td>
          <td class="code">
	        
            <div class="highlight"><pre>    <span class="nx">opsFinal</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ops</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;ops:&quot;</span><span class="p">,</span> <span class="nx">opsFinal</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

          </td>
        </tr>
        
      </table>
      
      <table>
        
        <tr>
          <td class="docs">
            <p>Eseguendo il nostro codice possiamo vedere che
sono state eseguite circa 800.000 operazioni in
un secondo.</p>

          </td>
          <td class="code leading">
	        
            <div class="highlight"><pre><span class="gp">$</span> go run stateful-goroutines.go
<span class="go">ops: 807434</span>
</pre></div>

          </td>
        </tr>
        
        <tr>
          <td class="docs">
            <p>Per questo caso particolare l&rsquo;approccio a goroutine
risulta migliore rispetto a quello basato su mutex.
Questo approccio risulta vincente nel caso in cui si
debbano gestire svariati channel oppure nei casi in
cui la gestione di troppe mutex potrebbe risultare
complesso. Il consiglio è quello di utilizzare
l&rsquo;approccio che risulta più naturale per ogni singolo
caso e che mantiene alta la leggibilità del proprio
codice.</p>

          </td>
          <td class="code empty">
	        
            
          </td>
        </tr>
        
      </table>
      
      
      <p class="next">
        Prossimo esempio: <a href="ordinamento">Ordinamento</a>.
      </p>
      
      <p class="footer">
        by <a href="https://twitter.com/cortinico">@cortinico</a> &amp; <a href="https://twitter.com/_tyge">@_tyge</a> | <a href="mailto:dahhowl@gmail.com,corti.nico@gmail.com">feedback</a> | <a href="https://github.com/golangit/gobyexample-it">source</a> | <a href="https://github.com/golangit/gobyexample-it#license">license</a>
      </p>
    </div>
  </body>
</html>
