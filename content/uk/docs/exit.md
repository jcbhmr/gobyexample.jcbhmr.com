# Exit
```go
// Скористайтесь `os.Exit` для негайного виходу з
// [відповідним статусом](https://en.wikipedia.org/wiki/Exit_status).

package main

import (
	"fmt"
	"os"
)

func main() {

	// Відкладений виклик ( за допомогою `defer`) ніколи не буде
	// запущено, якщо використовується `os.Exit`, тобто `fmt.Println`
	// просто не виконається.
	defer fmt.Println("!")

	// Завершити з програму з статусом 3.
	os.Exit(3)
}

// Напротивагу С/С++, Go не потребує використовувати
// ціле число, як значення що повертається з функції main
// (щоб вказати операційні системі з яким статусом
// завершилась програма). Тобто, якщо ви захочете
// вийти з ненульовим статусом - ви змушені будете
// скористатись `os.Exit`.
```
```sh
# Якщо ви запустите `exit.go` використовуючи
# `go run`, то статус виходу буде підібрано
# `go` і надруковано.
$ go run exit.go
exit status 3

# Якщо ви скомпілюєте та запустите бінарний файл,
# ви зможете підхопити статус код в терміналі
# самостійно.
$ go build exit.go
$ ./exit
$ echo $?
3

# Зауважте що `!` з нашої програми ніколи не
# буде надруковано.
```
