# Замикання|Closures
```go
// [_Анонімні функції_](https://uk.wikipedia.org/wiki/Анонімна_функція) (які підтримуються в Go)
// можуть створювати [_замикання_](https://uk.wikipedia.org/wiki/Замикання_(програмування)).
// Це стає в нагоді, за умов коли необхідно декларувати
// функцію без найменування і поводитись з нею, як з простою змінною.

package main

import "fmt"

// В нашому прикладі функція `intSeq` створює та повертає іншу функцію,
// оголошуну анонімно в тілі `intSeq`. Функція, що
// повертається, замикається на змінні `i` та формує так зване `замикання`
// або `closure`.
func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}

func main() {

	// Викликаючи `intSeq` ми присвоюємо її результат (нашу анонімну функцію)
	// змінній `nextInt`. Ця функціональна змінна, замикається над
	// власним  значенням змінної `i`, яка оновлюватиметься щоразу `nextInt` буде викликано.
	nextInt := intSeq()

	// Для демонстрації - зробимо кілька викликів `nextInt`.
	fmt.Println(nextInt())
	fmt.Println(nextInt())
	fmt.Println(nextInt())

	// І щоб показати що цей стан є унікальним, створимо нове
	// замикання і відразу викличмо його.
	newInts := intSeq()
	fmt.Println(newInts())
}
```
```sh
$ go run closures.go
1
2
3
1

# Наостанок звернемо увагу на ще одну особливість
# функцій - рекурсію.
```
