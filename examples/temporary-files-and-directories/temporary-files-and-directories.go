// Во время выполнения программы мы часто хотим создавать
// данные, которые не нужны после выхода из программы.
// *Временные файлы и каталоги* полезны для этой цели,
// поскольку они не загрязняют файловую систему с
// течением времени.

package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func main() {

	// Простейший способ создания временного файла - это
	// вызов `ioutil.TempFile`. Он создаст *и* откроет
	// файл для чтения и записи. Мы использовали `""` в
	// качестве первого аргумента, и поэтому `ioutil.TempFile`
	// создаст файл в директории по-умолчанию.
	f, err := ioutil.TempFile("", "sample")
	check(err)

	// Показать имя временного файла. В ОС на основе Unix
	// каталог, вероятно, будет `/tmp`. Имя файла начинается
	// с префикса, заданного в качестве второго аргумента
	// `ioutil.TempFile`, а остальное выбирается автоматически,
	// чтобы параллельные вызовы всегда создавали разные
	// имена файлов.
	fmt.Println("Temp file name:", f.Name())

	// Удалите файл после того, как мы закончим. Через
	// некоторое время ОС, скорее всего, сама очистит
	// временные файлы, но рекомендуется делать это явно.
	defer os.Remove(f.Name())

	// Мы можем записать какую-то информацию в файл.
	_, err = f.Write([]byte{1, 2, 3, 4})
	check(err)

	// Если мы намереваемся написать много временных файлов,
	// мы можем предпочесть создать *временный каталог*. Аргументы
	// `ioutil.TempDir` совпадают с аргументами `TempFile`,
	// но он возвращает *имя каталога*, а не открытый файл.
	dname, err := ioutil.TempDir("", "sampledir")
	fmt.Println("Temp dir name:", dname)

	defer os.RemoveAll(dname)

	// Теперь мы можем синтезировать временные имена
	// файлов, добавив к ним префикс нашего
	// временного каталога.
	fname := filepath.Join(dname, "file1")
	err = ioutil.WriteFile(fname, []byte{1, 2}, 0666)
	check(err)
}
