// Під час виконання програми ми часто хочемо створити
// дані, які після закінчення програми можуть бути непотрібні.
// *Тимчасові файли та каталоги* гарно підходять для цієї задачі,
// оскільки вони не забруднюють файлову систему.

package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func main() {

	// Найпростіший спосіб створити тимчасовий файл
	// - використати `ioutil.TempFile`.
	// Він створює файл *та* відкриває його для читання
	// і запису. Як перший аргумент ми передаємо `""`,
	// для того щоб `ioutil.TempFile` створив файл,
	// розташування якого буде за замовчуванням для нашої ОС.
	f, err := os.CreateTemp("", "sample")
	check(err)

	// Відобразить ім'я тимчасового файлу.
	// У UNIX-подібних системах, каталог, швидше за все,
	// буде `/tmp`. Ім'я файлу починається з префіксу,
	// який ми вказали у другому аргументі `ioutil.TempFile`,
	// а решта генерується автоматично, щоб гарантувати, що
	// паралельні виклики завжди створюватимуть різні імена файлів.
	fmt.Println("Temp file name:", f.Name())

	// Видалимо файл після того, як ми закінчимо.
	// ОС, швидше за все, очищає тимчасові файли
	// самостійно через деякий час, але краще зробити це явно.
	defer os.Remove(f.Name())

	// Ми можемо записати деякі данні в файл.
	_, err = f.Write([]byte{1, 2, 3, 4})
	check(err)

	// Якщо ми маємо намір створювати багато тимчасових файлів,
	// ми можемо вважати що краще створити тимчасовий *каталог*.
	// Аргументи `ioutil.TempDir` такі ж, як і у` TempFile`,
	// але результатом буде ім'я *каталогу*.
	dname, err := os.MkdirTemp("", "sampledir")
	check(err)
	fmt.Println("Temp dir name:", dname)

	defer os.RemoveAll(dname)

	// Тепер ми можемо створити ім'я файлу
	// додавши префікс до тимчасового каталога.
	fname := filepath.Join(dname, "file1")
	err = os.WriteFile(fname, []byte{1, 2}, 0o666)
	check(err)
}
