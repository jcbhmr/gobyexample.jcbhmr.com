# Синхронізація каналу|Channel Synchronization
```go
// Основне застосування каналів - синхронізація між горутинами.
// Скористаємось властивістю каналів до блокування, щоб зачекати
// завершення роботи горутини. Якщо ви чекаєте завершення
// роботи кількох горутин - спробуйте [WaitGroup](waitgroups).

package main

import (
	"fmt"
	"time"
)

// Ця функція буде запущена в горутині. Канал `done`
// буде використано для надсилання повідомлення головній
// горутині про завершення роботи поточного функціоналу.
func worker(done chan bool) {
	fmt.Print("working...")
	time.Sleep(time.Second)
	fmt.Println("done")

	// Надсилаємо повідомлення про завершення роботи.
	done <- true
}

func main() {

	// Створимо канал `done` і запускаємо горутину `worker`,
	// виділивши цей канал їй для комунікації.
	done := make(chan bool, 1)
	go worker(done)

	// Чекаємо повідомлення про завершення роботи `worker`'a,
	// з каналу до якого ми передали повідомлення.
	<-done
}
```
```sh
# Якщо ви приберете `<-done` з коду,
# то програма завершиться, ще до того як `worker`
# буде запущено.
$ go run channel-synchronization.go
working...done
```
